## 2. 設計書

**システムアーキテクチャ概要:**
本アプリケーションは、Next.jsを用いたフロントエンド主導のアーキテクチャを採用します。ユーザーインターフェースはReactコンポーネントで構成され、電子書籍閲覧ビューアや要約結果表示などを提供します。サーバサイドでは、Next.jsのAPIルートを利用して要約リクエストを代理送信する簡易バックエンドとして動作します（必要に応じて）。MVP段階ではサーバ側に状態を持たず、アップロードされたEPUBデータはブラウザ上（メモリ上）で解析・表示することを基本とします。ただし、OpenAI互換APIの呼び出しにおいて、クライアントから直接外部APIを叩くとCORSやAPIキー露出の問題がある場合は、Next.jsサーバ経由（サーバ側でAPIを呼び出し）するアプローチを取ります。全体構成としては、**ブラウザUI (Next.jsフロント)** + **要約APIプロキシ (Next.js API routes)** というシンプルな二層構造です。

### コンポーネント設計

* **アップロードコンポーネント:** ユーザーがEPUBファイルを選択・アップロードするUIを提供します。Next.jsのページ初期画面（ホーム画面）にファイル入力フォームを配置し、ファイル選択イベント時にブラウザ上でEPUBファイルを読み込みます。FileReader APIを使用してEPUB（zip形式）を読み込み、圧縮ファイル内の必要なエントリ（OPFや各章のxhtmlファイル等）を取得します。アップロード後はアプリ内の状態（例えばReactのContextや状態管理ライブラリ）に書籍データを保持し、閲覧ビューに遷移します。エラー時（例：EPUB以外のファイル選択や解析失敗）にはユーザーにエラー通知します。ファイルの保持は一時的で、ブラウザをリロードすると消える想定です（ログイン実装後はサーバ保存も検討）。

* **EPUB解析モジュール:** EPUBファイルを解析するロジックを担うモジュールです。外部ライブラリの活用も検討します。具体的には、EPUB.jsもしくは類似のオープンソースライブラリを使用してコンテンツを解析・レンダリングします。React用のラッパーであるReact-Readerを利用すると、iframe内にEPUB内容を展開し、簡易にビューワを構築できます。このモジュールでは目次（TOC）の取得、章ごとの本文テキスト抽出、ページング情報の取得などを行います。ページ番号での指定を可能にするため、EPUB.jsの提供する位置情報（EPUB CFI: Canonical Fragment Identifier）や、ページモードが利用できる場合はそのAPIを活用します。MVPでは「章」を主単位とし、ページ番号指定は各章内のページ相当位置を計算して対応する簡易実装とします（厳密なページネーションは後続対応）。

* **電子書籍ビューアコンポーネント:** EPUB内容を表示するビューア部分です。React上のコンポーネント`BookViewer`（仮称）は、現在の章の内容を画面に表示し、章移動やページ移動のUIを含みます。UI要素としては：

  * ヘッダーまたはサイドパネルに\*\*目次(TOC)\*\*を表示し、章タイトル一覧から選択した章にジャンプ可能にする。
  * **本文表示エリア:** iframeもしくはdiv内に章本文（HTML）をレンダリングし、適宜スタイルを当てて読みやすくする。基本的な段落、見出し、リスト等のHTML要素に対応する。画像や特殊なレイアウトはMVPでは簡易表示（無視またはALT表示可）とする。
  * **ナビゲーション:** 次の章・前の章へ移動するボタン、もしくはページ単位の送りボタンを配置する。スクロール表示の場合は無限スクロールや「次の章を読み込む」ボタンなどでもよい。
  * **ページ番号表示:** ページ送りモードの場合、現在のページ番号と全体ページ数を表示する。スクロールモードの場合は進捗（％）や章番号表示程度に留める。

  ビューアは初期実装では簡素でよいですが、将来的に検索やハイライト機能を追加できるよう、DOM構造や状態管理を工夫します。例えば、テキスト選択範囲を取得するAPIや注釈挿入のスペースを確保しておくなど。React-Reader等を採用した場合は、提供されるコールバック（例えば位置変更イベントで現在章や位置を把握）を活用し、自前で章インデックスやタイトルを管理します。

* **要約リクエストコンポーネント:** ユーザーが要約したい範囲を指定しリクエストを送信するUIを提供します。`SummaryRequest`コンポーネントをビューア画面内に配置し、以下の要素を含みます：

  * 範囲指定入力：章またはページ範囲を指定するフィールド。例えばテキスト入力で「第1章」や「Ch1-3」「p10-20」のように記述可能にするか、UIとして開始章・終了章のドロップダウン、ページ番号入力欄などを用意します。MVPではシンプルにテキストフィールド＋説明ラベル（入力例を表示）で実装し、将来UIを改善することを想定します。
  * 実行ボタン：要約を開始するボタン。クリック時に入力をパースし、範囲を解釈して対象テキストを取得、そのテキストと要約指示を要約APIに送信します。
  * API呼び出し方法：基本はNext.jsのAPIルート（例：`/api/summary`）にPOSTし、サーバ側で外部のOpenAI互換APIへリクエストします。リクエスト内容はChatGPT API形式に従い、システムメッセージで「以下の文章を要約してください」等を指示、ユーザーメッセージとして対象テキストを含めて送信する形を想定します。ユーザー指定のAPIエンドポイントは環境変数またはリクエストボディで渡され、サーバ側でそのURLに対してHTTPリクエスト（POST）を行います。外部APIキーが必要な場合は、ユーザーから入力済みのキーを利用してヘッダー付与します。
  * レスポンス処理：サーバから要約結果（文章テキスト）を受け取ったら、`SummaryResult`コンポーネントに渡して表示させます。処理中はロード中スピナーや「要約生成中...」といったメッセージを表示し、結果が来たら置き換えます。

* **要約結果コンポーネント:** 要約APIから取得した結果を表示する`SummaryResult`コンポーネントです。ビューア画面内またはモーダルダイアログとして、ユーザーが閲覧中の本の要約を見やすい形で提示します。要約結果はおおむね段落テキストですが、内容に応じて箇条書きや番号リストになる可能性もあります。Markdown形式で返ってきた場合はレンダリング対応（必要ならサードパーティのMarkdownレンダラを利用）します。結果表示エリアはスクロール可能にし、長い要約にも対応します。また、「閉じる」や「再実行」ボタン、別範囲で再度要約要求を行うためのUI（元のSummaryRequestを再利用）も近くに配置して、ユーザーが要約結果を参考に再度別範囲を要約しやすい導線とします。

* **設定コンポーネント:** ユーザーがOpenAI Chat API互換エンドポイントのURLやAPIキーを入力・保存するためのUIです。メニュー画面またはヘッダーの設定ボタンからアクセスできる設定ダイアログを提供し、以下を含みます：

  * APIエンドポイントURL入力欄：ベースURLまたはエンドポイントのパスを入力。
  * APIキー入力欄：必要に応じて（例えばOpenAI公式APIを使うなら）ユーザーのAPIキーを入力。入力内容は画面上マスクし、ローカルストレージ等に保存する際も暗号化や最低限の可視化対策を行います。
  * 保存ボタン：入力された情報をブラウザの安全な領域（MVPではstateやメモリ、または一時的にLocalStorageに保存して次回アクセスで再入力不要にするオプションも検討）に保存し、以降の要約リクエスト時に参照できるようにします。設定が保存されたらユーザーに通知（例：「設定を保存しました」）します。
  * **設定情報の利用:** 保存されたエンドポイント情報はNext.jsの環境変数的に扱えるよう、例えばクライアント側からAPIルート呼び出し時に一緒に渡すか、あるいは一度サーバに保存（MVPではサーバ保存しない方針なので、毎回リクエスト時にパラメータで送る形で十分）。このコンポーネントはまた、設定情報のバリデーション（URLの形式チェックなど）も行います。

### データフローと内部処理

1. **ファイルアップロードから表示まで:**
   ユーザーがEPUBファイルを選択すると、`UploadComponent`がファイル内容を取得し、`EpubParser`（解析モジュール）に渡します。解析モジュールはEPUBのメタデータや目次、各章のコンテンツを抽出し、構造化データ（例えば：{タイトル, 章一覧:\[{章タイトル, ファイルパス/ID, 章本文HTML}, ...]}）を生成します。このデータはReactの状態（ContextやReduxなど）に格納されます。アップロード完了後、画面は`BookViewer`コンポーネントを表示し、自動的に章一覧の最初の章内容をロードして本文エリアにレンダリングします。ユーザーは画面上で他の章を選択すると、その章のHTMLがビューアにロードされます。ページ指定でのナビゲーションがある場合、章内で該当の位置へスクロールする処理を行います。

2. **要約要求の流れ:**
   ユーザーが要約範囲を入力して要約実行ボタンを押すと、`SummaryRequest`コンポーネントは現在保持している書籍データから指定された範囲のテキストを収集します。例えば「第1章～第2章」の場合、該当章の本文テキスト（タグを除去したプレーンテキスト、もしくは適度に改行等整形したテキスト）を連結します。「ページ10～20」のような指定であれば、まずページ10の属する章を特定し、その章テキスト内の該当範囲（ページ計算は簡易的に全体テキスト長とページ数から割合計算するなど）を抜き出し、ページ20まで他の章にまたがるなら次章も含めて取得します。取得したテキストが過大な長さの場合、モデルのトークン制限内になるよう一部カットオフまたはユーザーに警告する処理も考慮します（MVPでは上限を超えない程度の範囲指定をユーザーが行う前提で深刻な対応はしない）。用意したテキストと要約指示を含むリクエストを、Next.jsの`/api/summary`エンドポイントへPOST送信します。サーバ側では、環境設定から取得したエンドポイントURLに対して、Chat Completion APIリクエストを投げます。この際のリクエストはOpenAI Chat API互換フォーマット（`model`, `messages`等を含むJSON）で構築します。モデル名やパラメータ（温度など）は設定またはサーバ側環境変数で定義しておきます。外部APIからレスポンスが来たら、サーバは要約結果（choices\[0].message.content 等）を取り出しクライアントに返します。クライアントは受け取った結果テキストを`SummaryResult`コンポーネントに渡し、画面に表示します。
   この一連の処理中、ユーザーにはロード中表示や進行状況のフィードバックを行います。また、要約結果受信後も、必要に応じてユーザーが別の要約をすぐリクエストできるよう`SummaryRequest`フォームは画面上に残す（または結果表示後に閉じても、再度開けるボタンを用意）想定です。

3. **設定データ利用の流れ:**
   ユーザーが設定画面で入力したAPIエンドポイントURLやキーは、ブラウザ側で持つため、要約リクエスト時にそれを付加して送ります。実装としては、`/api/summary`呼び出し時にリクエストボディにエンドポイントURLとキーを含める、あるいはサーバではなくクライアントが直接fetchする場合は直接そのURLへfetchすることも考えられます（この場合CORS許可が必要です）。MVPの設計ではセキュリティと実装容易性の両面から、一旦サーバ経由を採用し、サーバ内で外部API先を可変にしています。従って、Next.js APIルートはリクエストボディ内の`endpoint`や`apiKey`フィールドを読み取り、その値でHTTPリクエストを行います（この方法ならOpenAI以外の互換APIでもURL・キーを差し替えるだけで利用可能です）。なお、設定値は揮発性（ページリロードで消える）でもMVPとしては問題ありませんが、利便性のためLocalStorageに保存しておき、ページロード時に読んでデフォルト入力値に反映する仕組みを持たせてもよいでしょう。

### 将来拡張のための設計上の考慮

* **他フォーマット対応:** EPUB以外のフォーマット（PDF, MOBIなど）を後日追加する際に、既存コードへの変更を最小限にできるよう意識します。具体的には、ファイルアップロード時にフォーマットを判別し、それぞれに対応するパーサ・ビューアモジュールへ処理を委譲する構造にします（例えばStrategyパターン的に、EPUBParser, PDFParser等を用意し、インタフェースを揃える）。ビューアコンポーネントも、ファイル種類によって内部実装を切り替えるか、もしくは各フォーマット専用のビューアコンポーネントをそれぞれ作成し、親コンポーネントが適切なものをレンダリングするようにします。こうした拡張性を確保することで、「マルチフォーマット対応」の要件にスムーズに応えられます（実際、類似アプリであるReadestではEPUB, MOBI, PDF等のマルチフォーマット対応が実装されています）。

* **ユーザー認証とマルチユーザー:** 今回はログイン不要の想定ですが、将来的にユーザーアカウント機能を追加する際に備え、ルーティングや状態管理を調整します。Next.jsにはNextAuth等の認証ライブラリがありますが、MVPでは導入しません。ただ、コード上で「ユーザーごと」にデータを保存する場面（例えば将来のクラウドストレージ連携など）が発生しても対応できるよう、現時点ではグローバル状態で持っている書籍データを、将来はユーザーIDに紐づけて保存できる構造（コンテキストをユーザー単位にする、APIを叩く際にユーザー情報も送れる設計など）を念頭に置きます。認証導入時に、大きくUIフローが変わらないよう、例えば「ファイルをアップロードして閲覧」という一連の画面遷移が、ログインしていればユーザー専用ライブラリに保存、ログインしていなければゲストモードで一時的に扱う、といった分岐が可能なようにコンポーネント設計を汎用化します。

* **要約機能の強化:** 現在は指定範囲をそのまま一度で要約していますが、さらに長大な範囲（本全体など）の要約や要約の精度向上のため、分割要約→マージのアプローチを導入できるようにします。これは、OpenAIが書籍全体の要約に用いた「小さな部分を要約し、それをまとめ上げる」手法をアプリ側で実施することです。将来的には例えば「全章要約」機能を追加し、その場合は章ごとに要約を取り、それらをさらに統合する要約をもう一度行う処理を自動化する、といった発展も考えられます。設計としては、要約リクエストのバックエンドロジックを差し替えられるよう関数単位で切り出しておき、単純要約 or 多段要約を選択できる構成にしておくことが有効です。

* **UI/UXの改善余地:** 本MVPのUIは必要最低限ですが、コード上はコンポーネント単位で分離しているため、例えばビューア部分を別のライブラリに置き換える、デザインフレームワーク（MuiやChakra UIなど）を導入してスタイルを当てる、といった改修が局所的に行えるようになります。また、多言語対応も視野に入れ、日本語以外のEPUBやUI表示言語切替えの要望に応えられるよう、文言をハードコーディングせず別ファイル管理するなどの対応も将来的検討事項です。
